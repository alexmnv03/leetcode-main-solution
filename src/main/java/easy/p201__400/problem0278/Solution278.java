package easy.p201__400.problem0278;

public class Solution278 {
    public int firstBadVersion(int n) {
        // Задача решается с помощью алгоритма двоичного поиска
        // Опредлеим указатели начала и конца начальной  области поиска
        int good = 0; //первый элемент всегда хороший, то мы можем утвердительно сказать. что good = n
        // В задании сказаноЮ что последний элемент всегда плохой, то мы можем утвердительно сказать. что bad = n
        int bad = n;
        // т.к. граница это разные числа (плохое и хорошее), то цикл можно заканчивать
        // когда разница между ними равно 1
        while(bad > good + 1) {
            // находим середину области
            int middle = good + (bad - good) / 2;
            // Если это число плохое, то смещаемся в левую область
            // В отличии от бинарного поиска границы области не смещаем, т.к. нам надо чтобы по краям
            // обасти были хороший и плохой элемент
            if (isBadVersion(middle)) {
                bad = middle;
            } else {
                // Если это число хорошее, то смещаемся в правую область
                good = middle;
            }
        }
        // т.к. нам надо вернуть первый плозой элемент
        return bad;
    }

    public static boolean isBadVersion(int version) {
        return true;
    }

}
